/*
 * Project :iCardea
 * File : PhrActor.java
 * Date : Feb 8, 2011
 * User : mradules
 */


package at.srfg.kmt.ehealth.phrs.security.model;


import java.util.Set;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.ManyToMany;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;

/**
 * Defies a generic actor, an actor is an entity that
 * can be involved in any kind of activity/action. <br/>
 * This entity defines the following named queries :
 * <ul>
 * <li> selectAllActors - returns all the persisted PhrActor instances. 
 * <li> countAllActors - counts all the PhrActor persisted instances. 
 * <li> selectActorsByName - returns all the persisted PhrActor instances where 
 * the name field exact match a specified one; this query requires a parameter named "name".
 * <li> selectActorsByNamePattern - returns all the persisted PhrActor instances where 
 * the name field exact match a specified one; this query requires a parameter named "name_pattern".
 * </ul>
 * 
 * @author Mihai
 * @version 0.0.1
 * @since 0.0.1
 */
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@NamedQueries({@NamedQuery(name="selectAllActors", 
                           query="SELECT actor FROM PhrActor AS actor"),
               @NamedQuery(name="countAllActors", 
                           query="SELECT COUNT(actor) FROM PhrActor AS actor"),
               @NamedQuery(name="selectActorsByName", 
                           query="SELECT actor FROM PhrActor AS actor WHERE actor.name=:name"),
               @NamedQuery(name="selectActorsByNamePattern", 
                           query="SELECT actor FROM PhrActor AS actor WHERE actor.name LIKE :name_pattern")
})
public class PhrActor {

    /**
     * A version number for this class so that serialization
     * can occur without worrying about the underlying class
     * changing between serialization and deserialization.
     */
    private static final long serialVersionUID = 5165L;

    /**
     * Unique id, is generated by the underlying persistence layer.<br>
     * <b>Note : <b> Don't use this property in any kind of logic,
     * this property is used only by the underly persistence layer.
     */
    private Long id;

    /**
     * The actor name.
     */
    private String name;

    /**
     * The group description.
     */
    private String description;
    
    private String uri;
    
    private Set<PhrRole> phrRoles;
    
    // FIXME : add the category

    /**
     * Builds a <code>PhrActor</code> instance.
     */
    public PhrActor() {
        // UNIMPLEMENTED
    }

    /**
     * Builds a <code>PhrActor</code> instance with a certain value for the name
     * property.
     * 
     * @param name the value for the name property, it can not be null.
     * @throws NullPointerException if the <code>name</code> argument is null.
     */
    public PhrActor(String name) {

        if (name == null) {
            throw new NullPointerException("The argument name can not be null.");
        }

        this.name = name;
    }

    /**
     * Returns the unique id for this Actor instance. <br>
     * <b>Note : <b> Don't use this property in any kind of logic,
     * this property is used only by the underly persistence layer.
     *
     * @return the unique id for this actor.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    public Long getId() {
        return id;
    }

    /**
     * Registers a new unique id for this Actor instance.<br>
     * <b>Note : <b> Don't set this property by hand (using this
     * method) and don't use this property any kind of logic.
     * This property is used only by the underly persistence layer.
     *
     * @param id the new unique id.
     */
    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns the description for this actor.
     *
     * @return the description for this actor.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Registers a new description for this actor instance.
     *
     *
     * @param description a new description for this actor instance.
     */
    public void setDescription(String description) {
        this.description = description;
    }
    
    @ManyToMany
    public Set<PhrRole> getPhrRoles() {
        return phrRoles;
    }

    public void setPhrRoles(Set<PhrRole> roles) {
        this.phrRoles = roles;
    }

    public String getUri() {
        return uri;
    }

    public void setUri(String uri) {
        this.uri = uri;
    }
    
    /**
     * Returns a string representation for this Group.
     * The string representation for this Group looks like
     * this :
     * <ul>
     * <li> the String 'Group{name='
     * <li> the name property
     * <li> the String ', uri='
     * <li> the uri property
     * <li> the String ', description='
     * <li> the description property
     * <li> the String '}'
     * </ul>
     *
     * @return a string representation for this Group.
     */
    @Override
    public String toString() {
        final String result =
                String.format("Group{name=%s, uri=%s, description=%s}", name, uri, description);
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        
        if (getClass() != obj.getClass()) {
            return false;
        }
        
        final PhrActor other = (PhrActor) obj;
        if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {
            return false;
        }
        
        if ((this.description == null) ? (other.description != null) : !this.description.equals(other.description)) {
            return false;
        }
        
        if ((this.uri == null) ? (other.uri != null) : !this.uri.equals(other.uri)) {
            return false;
        }
        return true;
    }

    @Override
    public int hashCode() {
        int hash = 5;
        return hash;
    }
}
